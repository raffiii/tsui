
/*

Copyright (C) 2014, Stefan Jänicke.

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the "Software"),
to deal in the Software without restriction, including without limitation
the rights to use, copy, modify, merge, publish, distribute, sublicense,
and/or sell copies of the Software, and to permit persons to whom the
Software is furnished to do so, subject to the following conditions:

1. The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

2. It is prohibited to remove, hide or modify any visual copyright notice
generated by this Software.

3. When using screenshots of any part of the visual output generated by
this Software for presentations or on websites the following link MUST
be clearly visible for the beholder: http://traviz.vizcovery.org

4. When using screenshots of any part of the visual output generated by
this Software in publications, the following reference MUST be inserted: 

S. Jänicke, A. Geßner, M. Büchler and G. Scheuermann (2014). Visualizations
for Text Re-use. In Proceedings of the 5th International Conference on
Information Visualization Theory and Applications, IVAPP 2014, pages 59–70.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

(Fair Academic License (FAL), http://vizcovery.org/fal.html)

*/

/**
 * -------------------------------------------------------
 * CLASS TRAVizConnection 
 * -------------------------------------------------------
 * represents the visual connection between 2 words
 * consists of vertical and horizontal connections (links)
 */
function TRAVizConnection(v1,v2,type){
	this.v1 = v1;
	this.v2 = v2;
	this.type = type;
	this.links = [];
}

/**
 * adds a link (vertical or horizontal) to the connection
 */
TRAVizConnection.prototype.addLink = function(link){
	this.links.push(link);
}


/**
 * -------------------------------------------------------
 * CLASS TRAVizVerticalConnection 
 * -------------------------------------------------------
 * represents a vertical connection
 * following a path, y1 is closer to the source vertex and y2 is closer to the sink vertex
 */
function TRAVizVerticalConnection(v1,v2,type){
	this.v1 = v1;
	this.v2 = v2;
	this.type = type;
}

/**
 * positions the vertical connection
 */
TRAVizVerticalConnection.prototype.position = function(x,y1,y2){
	this.x1 = x;
	this.x2 = x;
	this.y1 = y1;
	this.y2 = y2;
}

/**
 * returns the minimum y value
 */
TRAVizVerticalConnection.prototype.yMin = function(){
	return Math.min(this.y1,this.y2);
}

/**
 * returns the mamimum y value
 */
TRAVizVerticalConnection.prototype.yMax = function(){
	return Math.max(this.y1,this.y2);
}


/**
 * -------------------------------------------------------
 * CLASS TRAVizHorizontalConnection
 * -------------------------------------------------------
 * represents a horizontal connection
 * following a path, x1 is closer to the source vertex and x2 is closer to the sink vertex
 */
function TRAVizHorizontalConnection(v1,v2,type){
	this.v1 = v1;
	this.v2 = v2;
	this.type = type;
}

/**
 * positions the horizotal connection
 */
TRAVizHorizontalConnection.prototype.position = function(x1,x2,y){
	this.x1 = x1;
	this.x2 = x2;
	this.y1 = y;
	this.y2 = y;
}
/*

Copyright (C) 2014, Stefan Jänicke.

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the "Software"),
to deal in the Software without restriction, including without limitation
the rights to use, copy, modify, merge, publish, distribute, sublicense,
and/or sell copies of the Software, and to permit persons to whom the
Software is furnished to do so, subject to the following conditions:

1. The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

2. It is prohibited to remove, hide or modify any visual copyright notice
generated by this Software.

3. When using screenshots of any part of the visual output generated by
this Software for presentations or on websites the following link MUST
be clearly visible for the beholder: http://traviz.vizcovery.org

4. When using screenshots of any part of the visual output generated by
this Software in publications, the following reference MUST be inserted: 

S. Jänicke, A. Geßner, M. Büchler and G. Scheuermann (2014). Visualizations
for Text Re-use. In Proceedings of the 5th International Conference on
Information Visualization Theory and Applications, IVAPP 2014, pages 59–70.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

(Fair Academic License (FAL), http://vizcovery.org/fal.html)

*/

/**
 * -------------------------------------------------------
 * CLASS TRAVizGraph
 * -------------------------------------------------------
 * graph structure implementation
 * requires the <config>uration object to retrieve unique vertex indices
 */
function TRAVizGraph(config){
	this.config = config;
	this.vertices = [];
	this.vertexMap = [];
}

/**
 * Getter for vertex with the given <index>
 */
TRAVizGraph.prototype.getVertex = function(index){
	return this.vertexMap[index];
}

/**
 * Removes the vertex with the given <index> from the graph
 */
TRAVizGraph.prototype.removeVertex = function(index){
	var v = this.vertexMap[index];
	for( var i=0; i<v.successors.length; i++ ){
		this.vertexMap[v.successors[i]].removePredecessor(index);
	}
	for( var i=0; i<v.predecessors.length; i++ ){
		this.vertexMap[v.predecessors[i]].removeSuccessor(index);
	}
	for( var i=0; i<this.vertices.length; i++ ){
		if( this.vertices[i] == v ){
			this.vertices.splice(i,1);
			break;
		}
	}
	delete this.vertexMap[index];
}

/**
 * Adds a vertex <v> to the graph
 */
TRAVizGraph.prototype.addVertex = function(v){
	this.vertices.push(v);
	this.vertexMap[v.index] = v;
}

/**
 * Clones the graph structure
 */
TRAVizGraph.prototype.clone = function(){
	var cg = new TRAVizGraph();
	cg.config = this.config;
	for( var i=0; i<this.vertices.length; i++ ){
		cg.addVertex(new TRAVizVertex(cg,this.vertices[i].index,this.vertices[i].token));
	}
	for( var i=0; i<this.vertices.length; i++ ){
		var v = this.vertices[i];
		var vc = cg.vertices[i];
		vc.count = v.count;
		for( var j=0; j<v.sources.length; j++ ){
			vc.sources.push(v.sources[j]);
		}
		for( var j=0; j<v.successors.length; j++ ){
			vc.addSuccessor(v.successors[j]);
			cg.vertexMap[v.successors[j]].addPredecessor(vc.index);
		}
		for( var j=0; j<v.predecessors.length; j++ ){
			vc.addPredecessor(v.predecessors[j]);
			cg.vertexMap[v.predecessors[j]].addSuccessor(vc.index);
		}
	}
	return cg;
}

/**
 * Merges the two vertices <v1> and <v2> of the graph to v12 and
 * tests, if the graph is acyclic starting from v12
 */
TRAVizGraph.prototype.isAcyclicFromVertex = function(v1,v2){
	var v = new TRAVizVertex(this,this.config.getVertexIndex(),v1.token);
	this.addVertex(v);
	v.count = v1.count + v2.count;
	for( var i=0; i<v1.sources.length; i++ ){
		v.sources.push(v1.sources[i]);
	}
	for( var i=0; i<v2.sources.length; i++ ){
		v.sources.push(v2.sources[i]);
	}
	for( var i=0; i<v1.predecessors.length; i++ ){
		var id = v1.predecessors[i];
		if( id == v1.index || id == v2.index ){
			id = v.index;
		}
		v.addPredecessor(id);
		this.vertexMap[id].addSuccessor(v.index);
	}
	for( var i=0; i<v2.successors.length; i++ ){
		var id = v2.successors[i];
		if( id == v1.index || id == v2.index ){
			id = v.index;
		}
		v.addSuccessor(id);
		this.vertexMap[id].addPredecessor(v.index);
	}
	for( var i=0; i<v1.successors.length; i++ ){
		var id = v1.successors[i];
		if( id == v1.index || id == v2.index ){
			id = v.index;
		}			
		v.addSuccessor(id);
		this.vertexMap[id].addPredecessor(v.index);
	}
	for( var i=0; i<v2.predecessors.length; i++ ){
		var id = v2.predecessors[i];
		if( id == v1.index || id == v2.index ){
			id = v.index;
		}
		v.addPredecessor(id);
		this.vertexMap[id].addSuccessor(v.index);
	}
	for( var i=0; i<this.vertices.length; i++ ){
		this.vertices[i].visited = 0;
		this.vertices[i].limit = this.vertices[i].predecessors.length;
		for( var j=0; j<this.vertices[i].predecessors.length; j++ ){
			if( this.vertices[i].predecessors[j] == v1.index ){
				this.vertices[i].limit--;
			}
			if( this.vertices[i].predecessors[j] == v2.index ){
				this.vertices[i].limit--;
			}
		}
	}
	v.visited = v.limit;
	var edges = [];
	for( var i=0; i<v.successors.length; i++ ){
		if( v.successors[i] != v1.index && v.successors[i] != v2.index ){
			edges.push({
				head: v,
				tail: this.getVertex(v.successors[i])
			});
		}
	}
	while( edges.length > 0 ){
		var new_edges = [];
		for( var i=0; i<edges.length; i++ ){
			var e = edges[i];
			e.tail.visited++;
			if( e.tail.visited > e.tail.limit ){
				this.removeVertex(v.index);
				return false;
			}
			for( var j=0; j<e.tail.successors.length; j++ ){
				if( v.successors[i] != v1.index && v.successors[i] != v2.index && e.tail.visited == 1 ){
					new_edges.push({
						head: e.tail,
						tail: this.getVertex(e.tail.successors[j])
					});
				}
			}
		}
		edges = new_edges;
	}
	this.removeVertex(v1.index);
	this.removeVertex(v2.index);
	return v;
}

/**
 * Tests, if the graph is acyclic
 */
TRAVizGraph.prototype.isAcyclic = function(){
	do {
		var n = this.vertices.length;
		for( var i=0; i<this.vertices.length; i++ ){
			var vi = this.vertices[i];
			var suc = vi.successors, pred = vi.predecessors;
			if( suc.length == 0 ){
				for( var j=0; j<pred.length; j++ ){
					this.vertexMap[pred[j]].removeSuccessor(vi.index);
				}
				vi.predecessors = [];
			}
		}
		for( var i=this.vertices.length; i>0; i-- ){
			var vi = this.vertices[i-1];
			if( vi.successors.length == 0 && vi.predecessors.length == 0 ){
				this.removeVertex(vi.index);
			}
		}
	}
	while( n > this.vertices.length );
	if( this.vertices.length > 0 ){
		return false;
	}
	return true;
}

/**
 * Prints all edges of the graph to the console
 */
TRAVizGraph.prototype.printVertices = function(){
	for( var i=0; i<this.vertices.length; i++ ){
		var v = this.vertices[i];
		for( var j=0; j<v.successors.length; j++ ){
			var v2 = this.getVertex(v.successors[j]);
			console.info(v.id+" ---> "+v2.id,v.token+" ---> "+v2.token);
		}
	}
}


/**
 * -------------------------------------------------------
 * CLASS Vertex
 * -------------------------------------------------------
 * Vertex object of the <graph> with a given <index> representing the <token>
 */
function TRAVizVertex(graph,index,token) {
	this.graph = graph;
	this.token = token;
	this.successors = [];
	this.predecessors = [];
	this.count = 1;
	this.traced = false;
	this.linked = true;
	this.sources = [];
	this.index = index;
}

/**
 * removes the vertex successor <suc>
 */
TRAVizVertex.prototype.removeSuccessor = function(suc){
	for( var i=0; i<this.successors.length; i++ ){
		if( this.successors[i] == suc ){
			this.successors.splice(i,1);
			return;
		}
	}		
}

/**
 * removes the vertex predecessor <pred>
 */
TRAVizVertex.prototype.removePredecessor = function(pred){
	for( var i=0; i<this.predecessors.length; i++ ){
		if( this.predecessors[i] == pred ){
			this.predecessors.splice(i,1);
			return;
		}
	}		
}

/**
 * adds the vertex successor <suc>
 */
TRAVizVertex.prototype.addSuccessor = function(suc){
	var found = false;
	for( var i=0; i<this.successors.length; i++ ){
		if( suc == this.successors[i] ){
			found = true;
			break;
		}
	}
	if( !found ){
		this.successors.push(suc);
	}
}

/**
 * adds the vertex predecessor <pred>
 */
TRAVizVertex.prototype.addPredecessor = function(pred){
	var found = false;
	for( var i=0; i<this.predecessors.length; i++ ){
		if( pred == this.predecessors[i] ){
			found = true;
			break;
		}
	}
	if( !found ){
		this.predecessors.push(pred);
	}
}
/*

Copyright (C) 2014, Stefan Jänicke.

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the "Software"),
to deal in the Software without restriction, including without limitation
the rights to use, copy, modify, merge, publish, distribute, sublicense,
and/or sell copies of the Software, and to permit persons to whom the
Software is furnished to do so, subject to the following conditions:

1. The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

2. It is prohibited to remove, hide or modify any visual copyright notice
generated by this Software.

3. When using screenshots of any part of the visual output generated by
this Software for presentations or on websites the following link MUST
be clearly visible for the beholder: http://traviz.vizcovery.org

4. When using screenshots of any part of the visual output generated by
this Software in publications, the following reference MUST be inserted: 

S. Jänicke, A. Geßner, M. Büchler and G. Scheuermann (2014). Visualizations
for Text Re-use. In Proceedings of the 5th International Conference on
Information Visualization Theory and Applications, IVAPP 2014, pages 59–70.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

(Fair Academic License (FAL), http://vizcovery.org/fal.html)

*/

/**
 * -------------------------------------------------------
 * CLASS TRAVizAligner 
 * -------------------------------------------------------
 * implementation of an own sentence alignment algorithm
 * requires the graph and the configuration object
 */
function TRAVizAligner(graph,config){
	this.graph = graph;
	this.config = config;
}

/**
 * normalizes the given <sentence> if configured; otherwise, only multiple whitespaces are removed
 */
TRAVizAligner.prototype.normalize = function(sentence){
	if( this.config.options.normalize ){
		sentence = sentence.toLowerCase();
		sentence = sentence.replace(/--/g, "");
		sentence = sentence.replace(/,/g, "");
		sentence = sentence.replace(/\./g, "");
		sentence = sentence.replace(/;/g, "");
		sentence = sentence.replace(/:/g, "");
		sentence = sentence.replace(/\(/g, "");
		sentence = sentence.replace(/\)/g, "");
		sentence = sentence.replace(/\[/g, "");
		sentence = sentence.replace(/\]/g, "");
		sentence = sentence.replace(/\'/g, "");
		sentence = sentence.replace(/\"/g, "");
		sentence = sentence.replace(/´/g, "");
		sentence = sentence.replace(/`/g, "");
		sentence = sentence.replace(/“/g, "");
		sentence = sentence.replace(/”/g, "");
		if( sentence.lastIndexOf(" ") == sentence.length - 1 ){
			sentence = sentence.substring(0,sentence.length-1);
		}
	}
	sentence = sentence.replace(/  /g, " ");
	return sentence;
};

/**
 * core component of the sentence alignment
 * a scoring procedure weights token pairs dependent on the number of occurrences
 * the vertices of a token pair are merged, if it does not produces a cycle in the graph
 */
TRAVizAligner.prototype.alignSentences = function(sentences){
	var sal = this;
	var words = [];
	var wordVertices = [];
	var tokenized = [];
	var lastVertex = undefined;
	var wordlist = [];
	var preferenceMerge = [];
	for( var i=0; i<sentences.length; i++ ){
		var sword = [];
		lastVertex = undefined;
		var sentence = this.normalize(sentences[i]);
		var tokens = sentence.split(" ");
		var t = [];
		for( var j=0; j<tokens.length; j++ ){
			var token = tokens[j];
			var contentToken = tokens[j];
			var id = false;
			if( token.indexOf("<>") != -1 ){
				id = token.substring(1,token.indexOf('>'));
				contentToken = token.substring(token.indexOf('>')+1);
				contentToken = contentToken.substring(0,contentToken.indexOf('<'));
				token = token.substring(0,token.indexOf('>')+1)+"<>";
			}
			var word = {
				id: i+"-"+j,
				word: token,
				sid: i,
				wid: j,
				gid: words.length
			};
			words.push(word);
			sword.push(word);
			t.push(word);
			var v = new TRAVizVertex(this.graph,this.config.getVertexIndex(),token);
			if( id ){
				v.preferenceId = id;
				if( typeof preferenceMerge[id] == "undefined" ){
					preferenceMerge[id] = { vertices:[v], tokens: [contentToken] };
				}
				else {
					preferenceMerge[id].vertices.push(v);
					preferenceMerge[id].tokens.push(contentToken);
				}
			}
			v.sources.push({
				sourceId: i,
				token: token
			});
			this.graph.addVertex(v);
			if( typeof lastVertex != 'undefined' ){
				lastVertex.addSuccessor(v.index);
				v.addPredecessor(lastVertex.index);
			}
			lastVertex = v;
			wordVertices[word.id] = v;
		}
		wordlist.push(sword);
		tokenized.push(t);
	}
	var sortBySize = function(s1,s2){
		if( s1.length > s2.length ){
			return -1;
		}
		if( s1.length == s2.length ){
			return 0;
		}
		return 1;
	}
	var pairs = [];
	var wordMatches = [];
	var nodes = [];
	var assignments = [];
	for( var i=0; i<words.length; i++ ){
		wordMatches.push([]);
		nodes.push(false);
		assignments.push(false);
	}
	for( var i=0; i<tokenized.length-1; i++ ){
		for( var j=i+1; j<tokenized.length; j++ ){
			var matches = this.pairAlignment(tokenized[i],tokenized[j],[]);
			if( matches.length == 0 ){
				continue;
			}
			matches.sort(sortBySize);
			var ms = "";
			for( var k=0; k<matches[0].length; k++ ){
				pairs.push({
					pair: matches[0][k],
					value: 2
				});
				var w1 = matches[0][k].w1;
				var w2 = matches[0][k].w2;
				wordMatches[w1.gid].push(w2);
				wordMatches[w2.gid].push(w1);
			}
		}
	}
	if( this.config.options.optimizeAlignment ){
		for( var i=0; i<pairs.length; i++ ){
			var w1 = pairs[i].pair.w1;
			var w2 = pairs[i].pair.w2;
			for( var j=0; j<wordMatches[w1.gid].length; j++ ){
				if( wordMatches[w1.gid][j] == w2 ){
					continue;
				}
				for( var k=0; k<wordMatches[w2.gid].length; k++ ){
					if( wordMatches[w2.gid][k] == w1 ){
						continue;
					}
					if( wordMatches[w1.gid][j] == wordMatches[w2.gid][k] ){
						pairs[i].value++;
					}
				}				
			}
		}
		var sortBySize2 = function(p1,p2){
			if( p1.value > p2.value ){
				return -1;
			}
			if( p1.value == p2.value ){
				return 0;
			}
			return 1;
		}
		pairs.sort(sortBySize2);
	}
	for( var i=0; i<preferenceMerge.length; i++ ){
		for( var j=0; j<preferenceMerge[i].vertices.length; j++ ){
			preferenceMerge[i].vertices[j].token = preferenceMerge[i].tokens[j];
		}
	}
	var checkMerge = function(w1,w2){
		var v1 = sal.graph.getVertex(wordVertices[w1.id].index), v2 = sal.graph.getVertex(wordVertices[w2.id].index);
		if( v1 == v2 ){
			return;
		}
		var v = sal.graph.isAcyclicFromVertex(v1,v2);
		if( v ){
			for( var i=0; i<words.length; i++ ){
				if( wordVertices[words[i].id] == v1 || wordVertices[words[i].id] == v2 ){
					wordVertices[words[i].id] = v;
				}
			}
		}
	}
	if( preferenceMerge.length > 0 ){
		for( var i=0; i<pairs.length; i++ ){
			var v1 = sal.graph.getVertex(wordVertices[w1.id].index), v2 = sal.graph.getVertex(wordVertices[w2.id].index);
			if( v1.preferenceId && v1.preferenceId == v2.preferenceId ){
				checkMerge(pairs[i].pair.w1,pairs[i].pair.w2);
				pairs[i].mark = true;
			}
		}
	}
	for( var i=0; i<pairs.length; i++ ){
		if( !pairs[i].mark ){
			checkMerge(pairs[i].pair.w1,pairs[i].pair.w2);
		}
	}
	var sentencePaths = [];
	for( var i=0; i<wordlist.length; i++ ){
		var sp = [this.graph.startVertex];
		for( var j=0; j<wordlist[i].length; j++ ){
			var v = wordVertices[wordlist[i][j].id];
			if( j == 0 ){
				this.graph.startVertex.addSuccessor(v.index);
				v.addPredecessor(this.graph.startVertex.index);
			}
			if( j == wordlist[i].length-1 ){
				v.addSuccessor(this.graph.endVertex.index);						
				this.graph.endVertex.addPredecessor(v.index);
			}
			sp.push(v);
		}
		sp.push(this.graph.endVertex);
		sentencePaths.push(sp);
	}
	return sentencePaths;
};

/**
 * returns the edit distance for two given words <a> and <b>
 * thankfully taken from: http://en.wikibooks.org/wiki/Algorithm_Implementation/Strings/Levenshtein_distance
 */
TRAVizAligner.prototype.getEditDistance = function(a,b){
	if( a.length === 0 ){
		return b.length;
	}
	if( b.length === 0 ){
		return a.length;
	} 
	var matrix = [];
	var i;
	for( i=0; i<=b.length; i++ ){
		matrix[i] = [i];
	}
	var j;
	for( j=0; j<=a.length; j++ ){
		matrix[0][j] = j;
	}
	for( i=1; i<=b.length; i++ ){
		for( j=1; j<=a.length; j++ ){
			if( b.charAt(i-1) == a.charAt(j-1) ){
				matrix[i][j] = matrix[i-1][j-1];
			}
			else {
				matrix[i][j] = Math.min(matrix[i-1][j-1]+1,Math.min(matrix[i][j-1]+1,matrix[i-1][j]+1));
			}
		}
	}
	return matrix[b.length][a.length];
};

/**
 * returns all possible paths with aligned tokens in the correct order between sentences <s1> and <s2>
 */
TRAVizAligner.prototype.pairAlignment = function(s1,s2){
	var matches = [];
	for( var i=0; i<s1.length; i++ ){
		matches.push([]);
		for( var j=0; j<s2.length; j++ ){
			if( this.config.options.editDistance ){
				var ld = this.getEditDistance(s1[i].word,s2[j].word);
				var red = 2*ld / (s1[i].word.length+s2[j].word.length);
				if( red <= this.config.options.editDistance ){
					matches[i].push(s2[j]);
				}
			}
			else if( s1[i].word == s2[j].word ){
				matches[i].push(s2[j]);
			}
		}
	}
	var paths = [];
	for( var i=0; i<matches.length; i++ ){
		var newPaths = [];
		var addPath = function(path1){
			var lNode1 = path1[path1.length-1];
			var found = false;
			var np = [];
			for( var j=newPaths.length; j>0; j-- ){
				var path2 = newPaths[j-1];
				var lNode2 = path2[path2.length-1];
				if( lNode1.w2 == lNode2.w2 && path1.length != path2.length ){
					if( path1.length <= path2.length ){
						np.push(path2);
						found = true;
					}
				}
				else if( lNode1.w2 == lNode2.w2 && path1.length == path2.length ){
					np.push(path2);
					found = true;
				}
				else {
					np.push(path2);
				}
			}
			if( !found ){
				np.push(path1);
			}
			newPaths = np;
		}
		for( var k=0; k<paths.length; k++ ){
			var path = paths[k];
			addPath(path);
			var lNode = path[path.length-1].w2;
			for( var j=0; j<matches[i].length; j++ ){
				var node = matches[i][j];
				if( node.wid > lNode.wid ){
					addPath(path.concat([{ w1: s1[i], w2: node}]));
				}
			}
		}
		for( var j=0; j<matches[i].length; j++ ){
			addPath([{ w1: s1[i], w2: matches[i][j]}]);
		}
		paths = newPaths;
	}
	return paths;
};

/**
 * computes the shortest strongest path in the graph structure
 * required to subsequently place the paths in form of layers
 */
TRAVizAligner.prototype.strongestShortestPath = function(s){
	var strength = 0, length = 1000000;
	var path = undefined;
	for( var i=0; i<s.successors.length; i++ ){
		var pi = [s];
		var si = s.count;
		var li = 1;
		var vertex = this.graph.getVertex(s.successors[i]);
		pi.push(vertex);
		if( !vertex.traced ){
			var vs = vertex.successors;
			si += vertex.count;
			while( vs.length > 0 ){
				var lc = this.graph.getVertex(vs[0]).count;
				var v = this.graph.getVertex(vs[0]);
				for( var j=1; j<vs.length; j++ ){
					if( this.graph.getVertex(vs[j]).count > lc ){
						lc = this.graph.getVertex(vs[j]).count;
						v = this.graph.getVertex(vs[j]);
					}
				}
				li++;
				pi.push(v);
				if( !v.traced ){
					si += lc;
					vs = v.successors;
				}
				else {
					vs = [];
				}
			}
		}
		if( li < length || li == length && si > strength ){
			length = li;
			strength = si;
			path = pi;
		}
	}
	return {
		strength: strength,
		length: length,
		path: path
	}
};

/**
 * computes all shortest strongest paths with a given <sentencePath> that is placed on layer 0
 */
TRAVizAligner.prototype.getPaths = function(sentencePath){
	for( var i=0; i<this.graph.vertices.length; i++ ){
		this.graph.vertices[i].traced = false;
	}
	var p = sentencePath;
	for( var i=0; i<p.length; i++ ){
		p[i].traced = true;
	}
	var paths = [p];
	var traverse = true;
	var runs = 0;
	while( traverse ){
		runs++;
		traverse = false;
		var c = undefined;
		for( var i=0; i<this.graph.vertices.length; i++ ){
			var v = this.graph.vertices[i];
			if( v.traced ){
				for( var k=0; k<v.successors.length; k++ ){
					if( !this.graph.getVertex(v.successors[k]).traced ){
						var p = this.strongestShortestPath(this.graph.getVertex(v.successors[k]));
						p.path.splice(0,0,v);
						if( typeof c == "undefined" || c.length > p.length || 
							c.length == p.length && p.strength > c.strength ){
							c = p;
						}
					}
				}
			}
			else {
				traverse = true;
			}
		}
		if( typeof c != "undefined" ){
			for( var i=0; i<c.path.length; i++ ){
				c.path[i].traced = true;
			}
			paths.push(c.path);
		}
	}
	return paths;
};

/**
 * computes all shortest strongest paths with a given <sentencePath> that is placed on layer 0
 */
TRAVizAligner.prototype.getPathsByEdition = function(sentencePath,sentencePaths){
	var spcopy = [];
	for( var i=0; i<sentencePaths.length; i++ ){
		if( sentencePath != sentencePaths[i] ){
			spcopy.push(sentencePaths[i]);
		}
	}
	for( var i=0; i<this.graph.vertices.length; i++ ){
		this.graph.vertices[i].traced = false;
	}
	var p = sentencePath;
	for( var i=0; i<p.length; i++ ){
		p[i].traced = true;
	}
	var paths = [p];
	while( spcopy.length > 0 ){
		var overlap = false, id = false, strength = false;
		for( var i=0; i<spcopy.length; i++ ){
			var ol = 0;
			var str = 0;
			for( var j=0; j<spcopy[i].length; j++ ){
				if( spcopy[i][j].traced ){
					ol++;
				}
				else {
					str += spcopy[i][j].count;
				}
			}
			if( !overlap || ol > overlap || ol == overlap && str > strength ){
				overlap = ol;
				id = i;
				strength = str;
			}
		}
		var pi = false;
		for( var i=0; i<spcopy[id].length; i++ ){
			if( !pi && !spcopy[id][i].traced ){
				pi = [spcopy[id][i-1],spcopy[id][i]];
			}
			else if( pi && spcopy[id][i].traced ){
				pi.push(spcopy[id][i]);
				paths.push(pi);
				pi = false;
			}
			else if( pi && !spcopy[id][i].traced ){
				pi.push(spcopy[id][i]);
			}
			spcopy[id][i].traced = true;
		}
		if( pi ){
			paths.push(pi);
		}
		spcopy.splice(id,1);
	}
	return paths;
};
/*

Copyright (C) 2014, Stefan Jänicke.

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the "Software"),
to deal in the Software without restriction, including without limitation
the rights to use, copy, modify, merge, publish, distribute, sublicense,
and/or sell copies of the Software, and to permit persons to whom the
Software is furnished to do so, subject to the following conditions:

1. The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

2. It is prohibited to remove, hide or modify any visual copyright notice
generated by this Software.

3. When using screenshots of any part of the visual output generated by
this Software for presentations or on websites the following link MUST
be clearly visible for the beholder: http://traviz.vizcovery.org

4. When using screenshots of any part of the visual output generated by
this Software in publications, the following reference MUST be inserted: 

S. Jänicke, A. Geßner, M. Büchler and G. Scheuermann (2014). Visualizations
for Text Re-use. In Proceedings of the 5th International Conference on
Information Visualization Theory and Applications, IVAPP 2014, pages 59–70.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

(Fair Academic License (FAL), http://vizcovery.org/fal.html)

*/

/**
 * -------------------------------------------------------
 * CLASS TRAViz
 * -------------------------------------------------------
 * main component of the system
 * requires the id of a <div> and optional individual configurations in form of a json object <options>
 * holds the graph and implements its visualization
 */
function TRAViz(div,options){
	this.div = div;
	this.config = new TRAVizConfig(options);
	this.curveRadius = this.config.options.curveRadius;
	this.graph = new TRAVizGraph(this.config);
	this.startVertex = new TRAVizVertex(this.graph,'first','');
	this.graph.addVertex(this.startVertex);
	this.endVertex = new TRAVizVertex(this.graph,'last','');
	this.graph.addVertex(this.endVertex);
	this.graph.startVertex = this.startVertex;
	this.graph.endVertex = this.endVertex;
}

/**
 * triggers the alignment of the given <sources> that evolves the Text Variant Graph
 */
TRAViz.prototype.align = function(sources){
	this.editions = [];
	this.sentences = [];
	this.colorMap = [];
	var colors = this.config.getColors(sources.length);
	for( var i=0; i<sources.length; i++ ){
		this.editions.push(sources[i].edition);
		this.sentences.push(sources[i].text);
		this.colorMap[sources[i].edition] = colors[i];
	}
	this.mainBranch = this.editions[0];
	this.aligner = new TRAVizAligner(this.graph,this.config);
	this.sentencePaths = this.aligner.alignSentences(this.sentences);
	this.sentencePathHash = [];
	for( var i=0; i<this.editions.length; i++ ){
		this.sentencePathHash[this.editions[i]] = this.sentencePaths[i];
	}
	this.vertices = this.aligner.graph.vertices;
	for( var i=0; i<this.vertices.length; i++ ){
		var v = this.vertices[i];
		var tl = "";
		var c = 0;
		var tokenNameHash = [];
		for( var j=0; j<v.sources.length; j++ ){
			var token = v.sources[j].token;
			var found = false;
			for( var k=0; k<tokenNameHash.length; k++ ){
				if( tokenNameHash[k].t == token ){
					tokenNameHash[k].c++;
					found = true;
					if( tokenNameHash[k].c > c ){
						tl = token;
						c = tokenNameHash[k].c;
					}
					break;
				}
			}
			if( !found ){
				tokenNameHash.push({
					t: token,
					c: 1
				});
				if( c == 0 ){
					tl = token;
					c = 1;
				}
			}
		}
		v.token = tl;
	}
	this.originGraph = this.graph.clone();
	this.originSentencePaths = [];
	for( var i=0; i<this.sentencePaths.length; i++ ){
		this.originSentencePaths.push([]);
		for( var j=0; j<this.sentencePaths[i].length; j++ ){
			this.originSentencePaths.push(this.sentencePaths[i][j]);
		}
	}
}

/**
 * triggers the alignment of the given <sources> that evolves the Text Variant Graph
 */
TRAViz.prototype.loadGraphML = function(xml){
	this.editions = [];
	this.sentences = [];
	this.colorMap = [];
	var colors = this.config.getColors(sources.length);
	for( var i=0; i<sources.length; i++ ){
		this.editions.push(sources[i].edition);
		this.sentences.push(sources[i].text);
		this.colorMap[sources[i].edition] = colors[i];
	}
	this.mainBranch = this.editions[0];
	this.aligner = new TRAVizAligner(this.graph,this.config);
	this.sentencePaths = this.aligner.alignSentences(this.sentences);
	this.sentencePathHash = [];
	for( var i=0; i<this.editions.length; i++ ){
		this.sentencePathHash[this.editions[i]] = this.sentencePaths[i];
	}
	this.vertices = this.aligner.graph.vertices;
	for( var i=0; i<this.vertices.length; i++ ){
		var v = this.vertices[i];
		var tl = "";
		var c = 0;
		var tokenNameHash = [];
		for( var j=0; j<v.sources.length; j++ ){
			var token = v.sources[j].token;
			var found = false;
			for( var k=0; k<tokenNameHash.length; k++ ){
				if( tokenNameHash[k].t == token ){
					tokenNameHash[k].c++;
					found = true;
					if( tokenNameHash[k].c > c ){
						tl = token;
						c = tokenNameHash[k].c;
					}
					break;
				}
			}
			if( !found ){
				tokenNameHash.push({
					t: token,
					c: 1
				});
				if( c == 0 ){
					tl = token;
					c = 1;
				}
			}
		}
		v.token = tl;
	}
	this.originGraph = this.graph.clone();
	this.originSentencePaths = [];
	for( var i=0; i<this.sentencePaths.length; i++ ){
		this.originSentencePaths.push([]);
		for( var j=0; j<this.sentencePaths[i].length; j++ ){
			this.originSentencePaths.push(this.sentencePaths[i][j]);
		}
	}
}

/**
 * updates all sentence paths after merge or split operations
 */
TRAViz.prototype.reset = function(v){
	for( var i=0; i<this.sentencePaths.length; i++ ){
		var p = this.sentencePaths[i];
		for( var j=p.length; j>0; j-- ){
			if( p[j-1].dummy ){
				p.splice(j-1,1);
			}
		}
	}
	for( var i=0; i<this.originGraph.vertices.length; i++ ){
		var v = this.originGraph.vertices[i];
		v.predecessors = [];
		v.successors = [];
	}
	for( var i=0; i<this.sentencePaths.length; i++ ){
		var p = this.sentencePaths[i];
		for( var j=0; j<p.length-1; j++ ){
			this.originGraph.getVertex(p[j].index).addSuccessor(p[j+1].index);
			this.originGraph.getVertex(p[j+1].index).addPredecessor(p[j].index);
		}
	}
	this.graph = this.originGraph.clone();
	this.aligner.graph = this.graph;
	this.vertices = this.graph.vertices;
	this.startVertex = this.graph.getVertex("first");
	this.endVertex = this.graph.getVertex("last");
	for( var i=0; i<this.sentencePaths.length; i++ ){
		var p = this.sentencePaths[i];
		for( var j=p.length; j>0; j-- ){
			p[j-1] = this.graph.getVertex(p[j-1].index);
		}
	}
	for( var i=0; i<this.vertices.length; i++ ){
		var v = this.vertices[i];
		v.layer = undefined;
		v.originLayer = undefined;
		var tl = "";
		var c = 0;
		var tokenNameHash = [];
		for( var j=0; j<v.sources.length; j++ ){
			var token = v.sources[j].token;
			var found = false;
			for( var k=0; k<tokenNameHash.length; k++ ){
				if( tokenNameHash[k].t == token ){
					tokenNameHash[k].c++;
					found = true;
					if( tokenNameHash[k].c > c ){
						tl = token;
						c = tokenNameHash[k].c;
					}
					break;
				}
			}
			if( !found ){
				tokenNameHash.push({
					t: token,
					c: 1
				});
				if( c == 0 ){
					tl = token;
					c = 1;
				}
			}
		}
		v.token = tl;
	}
}

/**
 * Overwrites the colormap
 */
TRAViz.prototype.setColorMap = function(colorMap){
	this.colorMap = colorMap;
}

/**
 * Initializes a 'visual' connection for each adjacent vertex pair
 * dependent on the layers of the corresponding vertices, a different connection type is assigned
 */
TRAViz.prototype.prepareConnections = function(){
	this.connections = [];
	var horizontalSlots = [];
	for( var i=0; i<this.layers.length; i++ ){
		var hs = {
			height: 0,
			paths: [],
			index: this.layers[i].index
		};
		horizontalSlots.push(hs);
	}
	var putHorizontalSlot = function(layer,hc){
		for( var i=0; i<horizontalSlots.length; i++ ){
			if( horizontalSlots[i].index == layer ){
				horizontalSlots[i].paths.push(hc);
				break;
			}
		}
	}
	var sal = this;
	var setSlotHeights = function(){
		var x_min = 1000000, x_max = 0;
		for( var i=0; i<sal.layout.length; i++ ){
			var v = sal.layout[i];
			if( v.x1 < x_min ){
				x_min = v.x1;
			}
			if( v.x2 > x_max ){
				x_max = v.x2;
			}
		}
		var equalGroups = function(g1,g2){
			if( g1.length != g2.length ){
				return false;
			}
			for( var i=0; i<g1.length; i++ ){
				if( g1[i] != g2[i] ){
					return false;
				}
			}
			return true;
		}
		for( var i=0; i<horizontalSlots.length; i++ ){
			var s = horizontalSlots[i];
			var max = 0;
			var groups = [];
			for( var j=x_min; j<x_max; j++ ){
				var group = [];
				for( var k=0; k<s.paths.length; k++ ){
					if( s.paths[k].v1.x2 < j && s.paths[k].v2.x1 > j ){
						group.push(s.paths[k]);
					}
				}
				if( group.length > 0 && ( groups.length == 0 || !equalGroups(groups[groups.length-1],group) ) ){
					groups.push(group);
				}
			}
			var max = 0;
			for( var j=0; j<groups.length; j++ ){
				if( groups[j].length > max ){
					max = groups[j].length;
				}
			}
			s.height = max*3 + 2*sal.curveRadius;
			s.groups = groups;
		}
	}
	for( var i=0; i<this.vertices.length; i++ ){
		var v = this.vertices[i];
		var p = v.successors;
		for( var j=0; j<p.length; j++ ){
			var v1 = v;
			var v2 = this.graph.getVertex(p[j]);
			if( !this.config.options.startAndEnd && ( v1 == this.startVertex || v2 == this.endVertex ) ){
				continue;
			}
			if( v.token == '' && v2.token == '' && !v2.linebreak && v2 != this.endVertex ){
				continue;
			}
			if( v1.layer == v2.layer ){
				var overlaps = false;
				for( var k=0; k<this.vertices.length; k++ ){
					if( this.vertices[k] == v1 || this.vertices[k] == v2 ){
						continue;
					}
					if( this.vertices[k].layer == v1.layer && v1.x1 < this.vertices[k].x1 && this.vertices[k].x1 < v2.x1 ){
						overlaps = true;
						break;
					}
				}
				if( overlaps ){
					var con = new TRAVizConnection(v1,v2,0);
					var vc1 = new TRAVizVerticalConnection(v1,v2,'source');
					var hc = new TRAVizHorizontalConnection(v1,v2,0);
					var vc2 = new TRAVizVerticalConnection(v1,v2,'sink');
					this.connections.push(con);
					con.addLink(vc1);
					con.addLink(hc);
					con.addLink(vc2);
					putHorizontalSlot(v1.layer,hc);
				}
				else {
					this.connections.push(new TRAVizConnection(v1,v2,-1));
				}
			}
			else {
				var con = new TRAVizConnection(v1,v2,3);
				this.connections.push(con);
				var vc1 = new TRAVizVerticalConnection(v1,v2,'source');
				var hc = new TRAVizHorizontalConnection(v1,v2,3);
				var vc2 = new TRAVizVerticalConnection(v1,v2,'sink');
				if( Math.abs(v1.layer) > Math.abs(v2.layer) ){
					if( v1.layer < 0 ){
						putHorizontalSlot(v1.layer+1,hc);
					} 
					else {
						putHorizontalSlot(v1.layer,hc);
					}
				}
				else {
					if( v2.layer < 0 ){
						putHorizontalSlot(v2.layer+1,hc);
					} 
					else {
						putHorizontalSlot(v2.layer,hc);
					}
				}
				con.addLink(vc1);
				con.addLink(hc);
				con.addLink(vc2);
			}
		}
	}
	setSlotHeights();
	this.horizontalSlots = horizontalSlots;
}

/**
 * Adds the given edge <e={h,t}> to its corresponding group
 */
TRAViz.prototype.addEdgeToGroup = function(h,t,e,ids){
	var found = false;
	for( var i=0; i<this.edgeGroups.length; i++ ){
		var g = this.edgeGroups[i];
		if( g.h == h && g.t == t ){
			g.edges.push(e);
			g.ids = g.ids.concat(ids);
			found = true;
			break;
		}
	}
	if( !found ){
		this.edgeGroups.push({
			h: h,
			t: t,
			edges: [e],
			ids: ids
		});
	}
}

/**
 * Adds the given edge <e={h,t}> to its corresponding group
 */
TRAViz.prototype.computeEdgeLabels = function(){
	for( var i=0; i<this.edgeGroups.length; i++ ){
		var g = this.edgeGroups[i];
		var tiptext = "";
		for( var j=0; j<g.ids.length; j++ ){
			tiptext += "<div style='text-align:center;color:"+this.colorMap[this.editions[g.ids[j]]]+";'>"+this.editions[g.ids[j]]+"</div>";
		}
	}
};

/**
 * Draws joined connections
 */
TRAViz.prototype.generalConnections = function(){		
	for( var i=0; i<this.connections.length; i++ ){
		var path = this.generatePath(this.connections[i],0,0);
		var pvis = this.paper.path(path).attr({stroke: this.config.options.baseColor, "stroke-width": 3, "stroke-linecap": "round", "opacity": "0.8"});
		this.basicConnections.push(pvis);
	}
	for( var i=0; i<this.vertices.length; i++ ){
		var v = this.vertices[i];
		if( v == this.startVertex || v == this.endVertex || v.token == '' ){
			continue;
		}
		if( this.config.options.vertexBackground ){
			v.rect.toFront();
		}
		if( v.count > this.config.options.collapseLabels ){
			v.textNode.toFront();
		}
	}
}

/**
 * Positions all required vertical connections 
 */
TRAViz.prototype.adjustVerticalConnections = function(){
	var verticals = [];
	for( var i=0; i<this.connections.length; i++ ){
		var c = this.connections[i];
		var x1 = c.v1.x2;
		var x2 = c.v2.x1;
		var xc = (x1+x2)/2;
		var y1 = (c.v1.y1+c.v1.y2)/2;
		var y2 = (c.v2.y1+c.v2.y2)/2;
		if( c.type == 1 ){
			var vy1, vy2;
			if( y1 > y2 ){
				vy1 = y1 - this.curveRadius;
				vy2 = y2 + this.curveRadius;
			}
			else {
				vy1 = y1 + this.curveRadius;
				vy2 = y2 - this.curveRadius;
			}
			var vc = c.links[0];
			vc.position(xc,vy1,vy2);
			verticals.push(vc);
		}
		else if( c.type == 0 || c.type == 3 ){
			var h = c.links[1];
			var v1x = x1 + this.curveRadius;
			var v1y1, v1y2;
			if( c.v1.layer >= c.v2.layer ){
				v1y1 = y1 - this.curveRadius;
				v1y2 = h.y1 + this.curveRadius;
			}
			else {
				v1y1 = y1 + this.curveRadius;
				v1y2 = h.y1 - this.curveRadius;
			}
			var vc1 = c.links[0];
			vc1.position(v1x,v1y1,v1y2);
			verticals.push(vc1);
			var v2x = x2 - this.curveRadius;
			var v2y1, v2y2;
			if( c.v1.layer <= c.v2.layer ){
				v2y1 = h.y1 + this.curveRadius;
				v2y2 = y2 - this.curveRadius;
			}
			else {
				v2y1 = h.y1 - this.curveRadius;
				v2y2 = y2 + this.curveRadius;
			}
			var vc2 = c.links[c.links.length-1];
			vc2.position(v2x,v2y1,v2y2);
			verticals.push(vc2);
		}
	}
	this.verticals = verticals;
	var sortVerticals = function(v1,v2){
		if( v1.x1 < v2.x1 ){
			return -1;
		}
		if( v1.x1 == v2.x1 && v1.yMax() > v2.yMax() ){
			return -1;
		}
		return 1;
	}
	verticals.sort(sortVerticals);
	var groups = [];
	for( var j=0; j<verticals.length; j++ ){
		var sourceFound = false;
		var sinkFound = false;
		for( var k=0; k<groups.length; k++ ){
			if( ( verticals[j].type == 'source' || verticals[j].type == 1 ) && groups[k].source == verticals[j].v1 ){
				sourceFound = true;
				groups[k].paths.push(verticals[j]);
				if( verticals[j].yMin() < groups[k].y1 ){
					groups[k].y1 = verticals[j].yMin();
				}
				if( verticals[j].yMax() > groups[k].y2 ){
					groups[k].y2 = verticals[j].yMax();
				}
			}
			if( ( verticals[j].type == 'sink' || verticals[j].type == 1 ) && groups[k].sink == verticals[j].v2 ){
				sinkFound = true;
				groups[k].paths.push(verticals[j]);
				if( verticals[j].yMin() < groups[k].y1 ){
					groups[k].y1 = verticals[j].yMin();
				}
				if( verticals[j].yMax() > groups[k].y2 ){
					groups[k].y2 = verticals[j].yMax();
				}
			}
		}
		if( !sourceFound && verticals[j].type != 'sink' ){
			groups.push({
				vertex: verticals[j].v1,
				source: verticals[j].v1,
				paths: [verticals[j]],
				y1: verticals[j].yMin(),
				y2: verticals[j].yMax(),
				x: verticals[j].v1.x2 + this.curveRadius
			});
		}
		if( !sinkFound && verticals[j].type != 'source' ){
			groups.push({
				vertex: verticals[j].v2,
				sink: verticals[j].v2,
				paths: [verticals[j]],
				y1: verticals[j].yMin(),
				y2: verticals[j].yMax(),
				x: verticals[j].v2.x1 - this.curveRadius
			});
		}
	}
	var sortGroupsBySize = function(g1,g2){
		if( g1.paths.length > g2.paths.length ){
			return 1;
		}
		if( g1.paths.length == g2.paths.length && Math.abs(g1.vertex.originLayer) < Math.abs(g2.vertex.originLayer) ){
			return 1;
		}
		return -1;
	}
	groups.sort(sortGroupsBySize);
	var groupsToPlace = [];
	for( var j=groups.length; j>0; j-- ){
		var g1 = groups[j-1];
		var ng1 = [];
		for( var k=0; k<g1.paths.length; k++ ){
			if( !g1.paths[k].placed ){
				ng1.push(g1.paths[k]);
			}
		}
		if( ng1.length < g1.paths.length ){
			if( ng1.length == 0 ){
				groups.pop();
				continue;
			}
			g1.paths = ng1;
			groups.sort(sortGroupsBySize);
			j = groups.length+1;
			continue;
		}
		for( var k=0; k<g1.paths.length; k++ ){
			g1.paths[k].placed = true;
		}
		groupsToPlace.push(g1);
		groups.pop();
	}
	groups = groupsToPlace;
	var sortGroupsByX = function(g1,g2){
		if( g1.x < g2.x ){
			return 1;
		}
		if( g1.x == g2.x ){
			if( g1.paths.length > g2.paths.length && g1.source ){
				return 1;
			}
		}
		return -1;
	}
	groups.sort(sortGroupsByX);
	var placedGroups = [];
	for( var j=groups.length; j>0; j-- ){
		var g1 = groups[j-1];
		if( typeof g1.source != 'undefined' ){
			var ox = g1.x;
			var nx = g1.paths[0].v1.x2 + this.curveRadius;
			if( ox != nx ){
				g1.x = nx;
				groups.sort(sortGroupsByX);
				j = groups.length+1;
				continue;
			}
		}
		if( typeof g1.sink != 'undefined' ){
			var ox = g1.x;
			var nx = g1.paths[0].v2.x1 - this.curveRadius;
			if( ox != nx ){
				g1.x = nx;
				groups.sort(sortGroupsByX);
				j = groups.length+1;
				continue;
			}
		}
		do {
			var overlap = false;
			for( var k=0; k<placedGroups.length; k++ ){
				var g2 = placedGroups[k];
				if( Math.abs(g1.x-g2.x) < this.config.options.edgeGap && !( g1.y1 > g2.y2 || g2.y1 > g1.y2 ) ){
					overlap = true;
					g1.x += this.config.options.edgeGap - Math.abs(g1.x-g2.x);
				}
			}
		}
		while(overlap);
		for( var k=0; k<g1.paths.length; k++ ){
			var p = g1.paths[k];
			p.x1 = g1.x;
			p.x2 = g1.x;
			p.gc = g1.paths.length;
			var v = p.v2;
			if( v.x1 - g1.x < this.curveRadius ){
				var s = this.curveRadius - ( v.x1 - g1.x );
				v.x1 += s;
				v.x2 += s;
				var pairs = [];
				for( var m=0; m<v.successors.length; m++ ){
					if( v.level == this.graph.getVertex(v.successors[m]).level ){
						pairs.push({
							head: v,
							tail: this.graph.getVertex(v.successors[m])
						});
					}
				}
				while( pairs.length > 0 ){
					var pairsNew = [];
					for( var m=0; m<pairs.length; m++ ){
						var v1 = pairs[m].head;
						var v2 = pairs[m].tail;
						if( v2.x1-v1.x2 < 4*this.curveRadius ){
							var sh = 4*this.curveRadius - ( v2.x1-v1.x2 ); 
							v2.x1 += sh;
							v2.x2 += sh;
							for( var n=0; n<v2.successors.length; n++ ){
								pairsNew.push({
									head: v2,
									tail: this.graph.getVertex(v2.successors[n])
								});
							}
						}
					}
					pairs = pairsNew;
				}
			}
		}
		placedGroups.push(g1);
		groups.pop();
	}
}

/**
 * Removes a vertical connection
 */
TRAViz.prototype.removeVertical = function(v){
	for( var i=0; i<this.verticals.length; i++ ){
		if( this.verticals[i] == v ){
			this.verticals.splice(i,1);
			return;
		}
	}	
}

/**
 * Removes overlaps between vertical connections and vertices
 */
TRAViz.prototype.removeOverlaps = function(){
	var sortVerticals = function(v1,v2){
		if( v1.x1 > v2.x1 ){
			return 1;
		}
		if( v1.x1 == v2.x1 ){
			return 0;
		}
		return -1;
	}
	for( var i=0; i<this.verticals.length; i++ ){
		for( var j=0; j<this.vertices.length; j++ ){
			if( this.vertices[j].token == '' ){
				continue;
			}
			var x11 = this.verticals[i].x1 - this.curveRadius, x12 = this.verticals[i].x2 + this.curveRadius, y11 = this.verticals[i].yMin() - this.curveRadius, y12 = this.verticals[i].yMax() + this.curveRadius;
			var x21 = this.vertices[j].x1, x22 = this.vertices[j].x2, y21 = this.vertices[j].y1, y22 = this.vertices[j].y2;
			if( this.overlap(x11,x12,x21,x22,y11,y12,y21,y22) ){
				var v1 = this.vertices[j];
				var ml = Math.abs(this.vertices[j].x2 - x11);
				var mr = Math.abs(v1.x1 - x12);
				var moved = false;
				var moveLeft = true;
				for( var k=0; k<this.vertices.length; k++ ){
					var v0 = this.vertices[k];
					if( v1 == v0 ){
						continue;
					}
					if( v0 == this.startVertex && !this.config.options.startAndEnd ){
						continue;
					}
					var con = this.getConnection(v0,v1);
					if( !con ){
						moveLeft = false;
					}
					else if( con.type == 1 && con.links[0].x1 + this.curveRadius >= v1.x1 - ml ){
						moveLeft = false;
					}
					else if( con.type == -1 && con.v2.x1 - con.v1.x2 - 3*this.curveRadius < ml ){
						moveLeft = false;
					}
					else if( con.type != -1 && con.type != 1 ){
						moveLeft = false;
					}
				}
				if( moveLeft ){
					moved = true;
					v1.x1 -= ml;
					v1.x2 -= ml;
				}
				if( !moved ){
					var moveRight = true;
					for( var k=0; k<this.vertices.length; k++ ){
						var v2 = this.vertices[k];
						if( v1 == v2 ){
							continue;
						}
						var con = this.getConnection(v1,v2);
						if( v2 == this.endVertex && !this.config.options.startAndEnd ){
							continue;
						}
						if( !con ){
							moveRight = false;
						}
						else if( con.type == 1 && con.links[0].x1 - this.curveRadius < v1.x2 + mr ){
							moveRight = false;
						}
						else if( con.type == -1 && con.v2.x1 - con.v1.x2 - 3*this.curveRadius < mr ){
							moveRight = false;
						}
						else if( con.type != -1 && con.type != 1 ){
							moveRight = false;
						}
					}
					if( moveRight ){
						moved = true;
						v1.x1 += mr;
						v1.x2 += mr;
					}
				}
				/*
				if( !moved ){
					var verticesToMove = [];
					var hash = [];
					var traverse = [v1];
					var layer = this.getLayer(v1.layer);
					layer.vertices.sort(sortVerticals);
					var locked = true;
					for( var m=0; m<layer.vertices.length; m++ ){
						if( !locked ){
							traverse.push(layer.vertices[m]);
						}
						if( layer.vertices[m] == v1 ){
							locked = false;
						}
					}
					while( traverse.length > 0 ){
						var newTraverse = [];
						for( var k=0; k<traverse.length; k++ ){
							if( !hash[traverse[k].index] ){
								hash[traverse[k].index] = true;
								traverse[k].x1 += mr;
								traverse[k].x2 += mr;
								for( var l=0; l<traverse[k].successors.length; l++ ){
									var suc = this.graph.getVertex(traverse[k].successors[l]);
									newTraverse.push(suc);
									var layer = this.getLayer(suc.layer);
									layer.vertices.sort(sortVerticals);
									var locked = true;
									for( var m=0; m<layer.vertices.length; m++ ){
										if( !locked ){
											newTraverse.push(layer.vertices[m]);
										}
										if( layer.vertices[m] == suc ){
											locked = false;
										}
									}
								}					
							}
						}
						traverse = newTraverse;
					}
					this.adjustVerticalConnections();
					this.verticals.sort(sortVerticals);
					i = 0;
				}*/
			}
		}
	}
	//this.setConnections();
}

/**
 * Transforms edges of type 3 into an edge of type 1, if possible
 */
TRAViz.prototype.transformEdgeTypes = function(){
	var horizontalSnippets = [];
	for( var i=0; i<this.connections.length; i++ ){
		var c = this.connections[i];
		if( c.type == 1 ){
			var v = c.links[0];
			var y1 = (c.v1.y1+c.v1.y2)/2;
			var y2 = (c.v2.y1+c.v2.y2)/2;
			horizontalSnippets.push({
				x1: c.v1.x2,
				x2: v.x1,
				y1: y1,
				y2: y1,
				v1: c.v1,
				v2: c.v2				
			});
			horizontalSnippets.push({
				x1: v.x1,
				x2: c.v2.x1,
				y1: y2,
				y2: y2,
				v1: c.v1,
				v2: c.v2				
			});
		}
	}
	for( var i=0; i<this.connections.length; i++ ){
		var c = this.connections[i];
		if( c.type == 0 || c.type == 3 ){
			var v1 = c.links[0];
			var h = c.links[1];
			var v2 = c.links[2];
			h.x1 = v1.x1 + this.curveRadius;
			h.x2 = v2.x1 - this.curveRadius;				
		}
	}
	var sortConnections = function(c1,c2){
		if( c1.v1.x2 > c2.v1.x2 ){
			return 1;
		}
		return -1;
	}
	this.connections.sort(sortConnections);
	for( var i=0; i<this.connections.length; i++ ){
		var c = this.connections[i];
		if( c.type == 3 ){
			var h = c.links[1];
			var y1 = (c.v1.y1+c.v1.y2)/2;
			var y2 = (c.v2.y1+c.v2.y2)/2;
			var x11 = h.x1 - this.curveRadius, x12 = h.x2 + this.curveRadius, y111 = c.v1.y1, y112 = c.v1.y2, y121 = c.v2.y1, y122 = c.v2.y2;
			var olV1 = false;
			var olV2 = false;
			for( var j=0; j<this.vertices.length; j++ ){
				var v = this.vertices[j];
				var x21 = v.x1, x22 = v.x2, y21 = v.y1, y22 = v.y2;
				if( this.overlap(x11,x12,x21,x22,y111,y112,y21,y22) ){
					olV1 = true;
					break;
				}				
				if( this.overlap(c.v2.x1-2*this.curveRadius,c.v2.x1,x21,x22,Math.min(y1,y2),Math.max(y1,y2),y21,y22) ){
//					olV1 = true;
//					break;
				}				
			}
			for( var j=0; j<horizontalSnippets.length; j++ ){
				var h = horizontalSnippets[j];
				if( c.v1 == h.v1 || c.v2 == h.v2 ){
					continue;
				}
				if( this.overlap(x11,x12,h.x1,h.x2,y111,y112,h.y1,h.y2) ){
					olV1 = true;
					break;
				}
			}
			for( var j=0; j<this.verticals.length; j++ ){
				var vert = this.verticals[j];
				if( c.v2 == vert.v2 ){
					continue;
				}
				if( this.overlap(c.links[2].x1,c.links[2].x1,vert.x1-this.config.options.edgeGap,vert.x2+this.config.options.edgeGap,Math.min(y1,y2),Math.max(y1,y2),Math.min(vert.y1,vert.y2),Math.max(vert.y1,vert.y2)) ){
					olV1 = true;
					break;
				}
			}
			for( var j=0; j<this.vertices.length; j++ ){
				var v = this.vertices[j];
				var x21 = v.x1, x22 = v.x2, y21 = v.y1, y22 = v.y2;
				if( this.overlap(x11,x12,x21,x22,y121,y122,y21,y22) ){
					olV2 = true;
					break;
				}
				if( this.overlap(c.v1.x2,c.v1.x2+2*this.curveRadius,x21,x22,Math.min(y1,y2),Math.max(y1,y2),y21,y22) ){
//					olV2 = true;
//					break;
				}				
			}
			for( var j=0; j<horizontalSnippets.length; j++ ){
				var h = horizontalSnippets[j];
				if( c.v1 == h.v1 || c.v2 == h.v2 ){
					continue;
				}
				if( this.overlap(x11,x12,h.x1,h.x2,y121,y122,h.y1,h.y2) ){
					olV2 = true;
					break;
				}
			}
			for( var j=0; j<this.verticals.length; j++ ){
				var vert = this.verticals[j];
				if( c.v1 == vert.v1 ){
					continue;
				}
				if( this.overlap(c.links[0].x1,c.links[0].x1,vert.x1-this.config.options.edgeGap,vert.x2+this.config.options.edgeGap,Math.min(y1,y2),Math.max(y1,y2),Math.min(vert.y1,vert.y2),Math.max(vert.y1,vert.y2)) ){
					olV2 = true;
					break;
				}
			}
			var draw1 = false, draw2 = false;
			if( olV1 && !olV2 ){
				draw1 = true;
			}
			else if( !olV1 && olV2 ){
				draw2 = true;
			}
			else if( !olV1 && !olV2 && c.links[0].gc > c.links[2].gc ){
				draw1 = true;
			}
			else if( !olV1 && !olV2 && c.links[0].gc < c.links[2].gc ){
				draw2 = true;
			}
			else if( !olV1 && !olV2 && Math.abs(c.v1.originLayer) < Math.abs(c.v2.originLayer) ){
				draw1 = true;
			}
			else if( !olV1 && !olV2 && Math.abs(c.v1.originLayer) >= Math.abs(c.v2.originLayer) ){
				draw2 = true;
			}
			if( draw1 ){
				c.type = 1;
				this.removeVertical(c.links[2]);
				var vc = c.links[0];
				vc.type = "source";
				var medl = (vc.v1.layer + vc.v2.layer)/2;
				if( vc.v1.layer < medl ){
					vc.y1 = y1 + this.curveRadius;
					vc.y2 = y2 - this.curveRadius;
				}
				else {
					vc.y1 = y1 - this.curveRadius;
					vc.y2 = y2 + this.curveRadius;
				}
				c.links = [vc];
				horizontalSnippets.push({
					x1: x11 - this.curveRadius,
					x2: x12 + this.curveRadius,
					y1: y121 - this.curveRadius,
					y2: y122 + this.curveRadius,
					v1: c.v1,
					v2: c.v2				
				});
			}
			if( draw2 ){
				c.type = 1;
				this.removeVertical(c.links[0]);
				var vc = c.links[2];
				vc.type = "sink";
				var medl = (vc.v1.layer + vc.v2.layer)/2;
				if( vc.v1.layer < medl ){
					vc.y1 = y1 + this.curveRadius;
					vc.y2 = y2 - this.curveRadius;
				}
				else {
					vc.y1 = y1 - this.curveRadius;
					vc.y2 = y2 + this.curveRadius;
				}
				c.links = [vc];
				horizontalSnippets.push({
					x1: x11 - this.curveRadius,
					x2: x12 + this.curveRadius,
					y1: y112 - this.curveRadius,
					y2: y112 + this.curveRadius,
					v1: c.v1,
					v2: c.v2				
				});
			}
		}
	}
}

/**
 * Positions all required horizontal connections 
 */
TRAViz.prototype.adjustHorizontalConnections = function(){
	var orderPaths = function(p1,p2){
		if( p1.type == 0 && p2.type == 0 ){
			if( p1.x2-p1.x1 < p2.x2-p2.x1 ){
				return -1;
			}
			return 1;
		}
		else if( p1.type == 0 ){
			return -1;
		}
		else if( p2.type == 0 ){
			return 1;
		}
		else {
			if( p1.x2 == p2.x2 ){
				if( p1.x1 < p2.x1 ){
					return -1;
				}
				return 1;
			}
			else if( p1.x2 < p2.x2 ){
				return -1;
			}
			return 1;
		}
	}
	for( var i=0; i<this.horizontalSlots.length; i++ ){
		var horizontals = [];
		var hs = this.horizontalSlots[i];
		var paths = hs.paths;
		for( var j=0; j<paths.length; j++ ){
			var hc = paths[j];
			var x1 = hc.v1.x2;
			var x2 = hc.v2.x1;
			var y = hs.yMax - 2;
			hc.position(x1+2*this.curveRadius,x2-2*this.curveRadius,y);
		}
		paths.sort(orderPaths);
		var groups = [];
		for( var j=0; j<paths.length; j++ ){
			var sourceFound = false;
			var sinkFound = false;
			for( var k=0; k<groups.length; k++ ){
				if( groups[k].source == paths[j].v1 ){
					sourceFound = true;
					groups[k].paths.push(paths[j]);
					if( paths[j].x1 < groups[k].x1 ){
						groups[k].x1 = paths[j].x1;
					}
					if( paths[j].x2 > groups[k].x2 ){
						groups[k].x2 = paths[j].x2;
					}
				}
				if( groups[k].sink == paths[j].v2 ){
					sinkFound = true;
					groups[k].paths.push(paths[j]);
					if( paths[j].x1 < groups[k].x1 ){
						groups[k].x1 = paths[j].x1;
					}
					if( paths[j].x2 > groups[k].x2 ){
						groups[k].x2 = paths[j].x2;
					}
				}
			}
			if( !sourceFound ){
				groups.push({
					source: paths[j].v1,
					paths: [paths[j]],
					x1: paths[j].x1,
					x2: paths[j].x2,
					y: paths[j].y1
				});
			}
			if( !sinkFound ){
				groups.push({
					sink: paths[j].v2,
					paths: [paths[j]],
					x1: paths[j].x1,
					x2: paths[j].x2,
					y: paths[j].y1
				});
			}
		}
		var sortGroups = function(g1,g2){
			if( g1.paths.length > g2.paths.length ){
				return 1;
			}
			return -1;
		}
		groups.sort(sortGroups);
		var placedGroups = [];
		for( var j=groups.length; j>0; j-- ){
			var g1 = groups[j-1];
			var ng1 = [];
			for( var k=0; k<g1.paths.length; k++ ){
				if( !g1.paths[k].placed ){
					ng1.push(g1.paths[k]);
				}
			}
			if( ng1.length < g1.paths.length ){
				g1.paths = ng1;
				groups.sort(sortGroups);
				j = groups.length+1;
				continue;
			}
			do {
				var overlap = false;
				for( var k=0; k<placedGroups.length; k++ ){
					var g2 = placedGroups[k];
					if( g1.y == g2.y && !( g1.x1 - this.curveRadius > g2.x2 || g2.x1 - this.curveRadius > g1.x2 ) ){
						overlap = true;
						g1.y -= this.config.options.edgeGap;
					}
				}
			}
			while(overlap);
			for( var k=0; k<g1.paths.length; k++ ){
				g1.paths[k].placed = true;
				g1.paths[k].y1 = g1.y;
				g1.paths[k].y2 = g1.y;
			}
			placedGroups.push(g1);
			groups.pop();
		}
	}
}

/**
 * When showing joined connections, this function can be called to highlight the path of edition <id>
 */
TRAViz.prototype.highlightEdition = function(id){
	var p = this.sentencePathHash[id];
	var path = "";
	for( var j=1; j<p.length; j++ ){
		path += this.generatePath(this.getConnection(p[j-1],p[j]),0,0);
	}
	var pvis = this.paper.path(path).attr({stroke: this.colorMap[id], "stroke-width": 4, "stroke-linecap": "round", "opacity": "1.0"});
	return pvis;
}

/**
 * Displays a line numbering when line breaks are used
 */
TRAViz.prototype.insertLineNumbering = function(width,gap){
	var line = 1;
	var x1 = this.curveRadius;
	var x2 = width - this.curveRadius;
	var y = this.layers[0].yLevel - this.layers[0].height/2 + 0.5 - Math.floor(gap/2) - 26;
	var path = "M "+x1+" "+y+" L "+x2+" "+y;
	this.paper.path(path).attr({stroke: this.config.options.baseColor, "stroke-width": 1, "stroke-linecap": "round", "opacity": "1.0"});
	this.paper.text(x1+7, y+14, this.config.options.lineNumberingText+" "+line).attr({font: "14px "+this.config.options.font,fill:this.config.options.baseColor,"text-anchor":"start","cursor":"default"});
	line++;
	for( var i=0; i<this.layers.length-1; i++ ){
		if( this.layers[i].level != this.layers[i+1].level ){
			var y = this.layers[i].yLevel + this.layers[i].height/2 + 0.5 + Math.floor(gap/2);
			var path = "M "+x1+" "+y+" L "+x2+" "+y;
			this.paper.path(path).attr({stroke: this.config.options.baseColor, "stroke-width": 1, "stroke-linecap": "round", "opacity": "1.0"});
			this.paper.text(x1+7, y+14, this.config.options.lineNumberingText+" "+line).attr({font: "14px "+this.config.options.font,fill:this.config.options.baseColor,"text-anchor":"start","cursor":"default"});
			line++;
		}
	}
	var y = this.layers[this.layers.length-1].yLevel + this.layers[this.layers.length-1].height/2 + 0.5 + Math.floor(gap/2);
	var path = "M "+x1+" "+y+" L "+x2+" "+y;
	this.paper.path(path).attr({stroke: this.config.options.baseColor, "stroke-width": 1, "stroke-linecap": "round", "opacity": "1.0"});
}

/**
 * Computes the path of the given <connection> with the given vertical shifts <s1> at the source vertex and <s2> at the sink vertex
 */
TRAViz.prototype.generatePath = function(connection,s1,s2){
	var bezier = function(x1,y1,xb,yb,x2,y2){
		return "C "+x1+" "+y1+" "+xb+" "+yb+" "+x2+" "+y2+" ";
	}
	var line = function(x1,y1,x2,y2){
		return "L "+x1+" "+y1+" "+x2+" "+y2+" ";
	}
	var c = connection;
	var x1 = c.v1.x2;
	var x2 = c.v2.x1;
	var y1 = (c.v1.y1+c.v1.y2)/2 + s1;
	var y2 = (c.v2.y1+c.v2.y2)/2 + s2;
	var path = "M "+x1+" "+y1+" ";
	if( c.type == -1 ){
		var xm = (x2+x1)/2;
		var ym = (y2+y1)/2;
		path += bezier(x1,y1,xm,y1,xm,ym);
		path += bezier(xm,ym,xm,y2,x2,y2);
	}
	else if( c.type == 0 || c.type == 3 ){
		var v1 = c.links[0];
		var h = c.links[1];
		var v2 = c.links[2];
		var v1x1 = v1.x1, v1x2 = v1.x2, v1y1 = v1.y1 + s1, v1y2 = v1.y2;
		var hx1 = h.x1, hx2 = h.x2, hy1 = h.y1, hy2 = h.y2;
		var v2x1 = v2.x1, v2x2 = v2.x2, v2y1 = v2.y1, v2y2 = v2.y2 + s2;
		var cr1 = this.curveRadius, cr2 = this.curveRadius;
		if( Math.abs(hy1-y1) < 2*this.curveRadius ){
			cr1 = Math.abs(hy1-y1)/2;
			var y = (hy1+y1)/2;
			v1y1 = y;
			v1y2 = y;
		}
		if( Math.abs(hy1-y2) < 2*this.curveRadius ){
			cr2 = Math.abs(hy1-y2)/2;
			var y = (hy1+y2)/2;
			v2y1 = y;
			v2y2 = y;
		}
		if( this.config.options.rtl ){
			cr1 *= -1;
			cr2 *= -1;
		}
		path += line(x1,y1,v1x1-cr1,y1);
		path += bezier(v1x1-cr1,y1,v1x1,y1,v1x1,v1y1);
		path += line(v1x1,v1y1,v1x2,v1y2);
		path += bezier(v1x2,v1y2,v1x2,hy1,hx1,hy1);
		path += line(hx1,hy1,hx2,hy2);
		path += bezier(hx2,hy2,v2x1,hy2,v2x1,v2y1);
		path += line(v2x1,v2y1,v2x2,v2y2);
		path += bezier(v2x2,v2y2,v2x2,y2,v2x2+cr2,y2);
		path += line(v2x2+cr2,y2,x2,y2);
	}
	else if( c.type == 1 ){
		var cr = this.curveRadius;
		if( this.config.options.rtl ){
			cr *= -1;
		}
		var link = c.links[0];
		path += line(x1,y1,link.x1-cr,y1);
		path += bezier(link.x1-cr,y1,link.x1,y1,link.x1,link.y1 + s1);
		path += line(link.x1,link.y1 + s1,link.x2,link.y2 + s2);
		path += bezier(link.x2,link.y2 + s2,link.x2,y2,link.x2+cr,y2);
		path += line(link.x2+cr,y2,x2,y2);
	}
	return path;
}

/**
 * Getter for connection between <v1> and <v2>
 */
TRAViz.prototype.getConnection = function(v1,v2){
	for( var i=0; i<this.connections.length; i++ ){
		if( this.connections[i].v1 == v1 && this.connections[i].v2 == v2 ){
			return this.connections[i];
		}
	}
	return false;
}

/**
 * Displays all paths that run through the given <vertex>
 */
TRAViz.prototype.displayVertexConnections = function(node,vertex){
	this.vertexConnections = [];
	for( var i=0; i<this.vertices.length; i++ ){
		this.vertices[i].ins = [];
		this.vertices[i].outs = [];
	}
	for( var i=0; i<this.sentencePaths.length; i++ ){
		var p = this.sentencePaths[i];
		for( var j=0; j<p.length; j++ ){
			if( p[j] == vertex ){
				for( var j=0; j<p.length; j++ ){
					if( j>0 ){
						p[j].ins.push({
							v: p[j-1],
							id: i
						});
					}
					if( j<p.length-1 ){
						p[j].outs.push({
							v: p[j+1],
							id: i
						});
					}
				}
			}
		}
	}
	for( var i=0; i<this.vertices.length; i++ ){
		var v = this.vertices[i];
		var yv = (v.y1+v.y2)/2;
		if( this.vertices[i].token == "" && ( this.vertices[i].ins.length <= 1 || this.vertices[i].outs.length <= 1 ) ){
			this.vertices[i].ins = [{}];
			this.vertices[i].outs = [{}];
		}
		this.vertices[i].ins.sort(function(t1,t2){			
			var y1 = (t1.v.y1+t1.v.y2)/2;
			var y2 = (t2.v.y1+t2.v.y2)/2;
			if( t1.v == t2.v && t1.id > t2.id ){
				return 1;
			}
			else if( t1.v != t2.v && y1 == y2 && t1.v.x2 > t2.v.x2 ){
				return 1;
			}
			else if( t1.v != t2.v && y1 > y2 ){
				return 1;
			}
			return -1;
		});
		this.vertices[i].outs.sort(function(t1,t2){
			var y1 = (t1.v.y1+t1.v.y2)/2;
			var y2 = (t2.v.y1+t2.v.y2)/2;
			if( t1.v == t2.v && t1.id > t2.id ){
				return 1;
			}
			else if( t1.v != t2.v && y1 == y2 && t1.v.x2 < t2.v.x2 ){
				return 1;
			}
			else if( t1.v != t2.v && y1 > y2 ){
				return 1;
			}
			return -1;
		});
	}
	var getShift = function(id,array){
		if( array.length == 1 ){
			return 0;
		}
		for( var i=0; i<array.length; i++ ){
			if( array[i].id == id ){
				return i*3 - array.length*3/2;
			}
		}
	}
	var getShiftHeight = function(id,array,height){
		if( array.length == 1 ){
			return 0;
		}
		for( var i=0; i<array.length; i++ ){
			if( array[i].id == id ){
				return (i*3 - array.length*3/2)/(array.length*2)*height/2;
			}
		}
	}
	for( var i=0; i<this.sentencePaths.length; i++ ){
		var p = this.sentencePaths[i];
		for( var j=0; j<p.length; j++ ){
			if( p[j] == vertex ){
				var path = "";
				for( var j=1; j<p.length; j++ ){
					var c = this.getConnection(p[j-1],p[j]);
					if( c ){
						if( this.config.options.interpolateFontSize ){
							path += this.generatePath(c,getShiftHeight(i,p[j-1].outs,p[j-1].boxHeight),getShiftHeight(i,p[j].ins,p[j].boxHeight));
						}
						else {
							path += this.generatePath(c,getShift(i,p[j-1].outs),getShift(i,p[j].ins));
						}
					}
				}
				var pvis = this.paper.path(path).attr({stroke: this.colorMap[this.editions[i]], "stroke-width": 3, "stroke-linecap": "round", "opacity": "0.8"});
				pvis.node.setAttribute("class","edition"+i+"-edgestyle");
				this.vertexConnections.push(pvis);
				break;
			}
		}
	}
	for( var i=0; i<this.vertices.length; i++ ){
		var v = this.vertices[i];
		if( v == this.startVertex || v == this.endVertex || v.token == '' ){
			continue;
		}
		if( this.config.options.vertexBackground ){
			v.rect.toFront();
		}
		if( v.count > this.config.options.collapseLabels ){
			v.textNode.toFront();
		}
	}
};

/**
 * Displays all connections and in case of majority=true, all majority edges are bundled
 */
TRAViz.prototype.majorityConnections = function(majority){
	var edges = [];
	for( var i=0; i<this.vertices.length; i++ ){
		for( var j=0; j<this.vertices[i].successors.length; j++ ){
			edges.push({
				head: this.vertices[i],
				tail: this.graph.getVertex(this.vertices[i].successors[j]),
				weight: 0,
				ids: []
			});
		}
	}
	var weightEdge = function(v1,v2,id){
		for( var i=0; i<edges.length; i++ ){
			var e = edges[i];
			if( e.head == v1 && e.tail == v2 ){
				e.weight++;
				e.ids.push(id);
			}
		}
	}
	for( var i=0; i<this.sentencePaths.length; i++ ){
		var p = this.sentencePaths[i];
		weightEdge(this.startVertex,p[0],i);
		weightEdge(p[p.length-1],this.endVertex,i);
		for( var j=0; j<p.length-1; j++ ){
			weightEdge(p[j],p[j+1],i);
		}
	}
	for( var i=0; i<this.vertices.length; i++ ){
		this.vertices[i].ins = [];
		this.vertices[i].outs = [];
	}
	for( var i=0; i<edges.length; i++ ){
		var e = edges[i];
		if( majority && e.weight > this.sentencePaths.length * this.config.options.majorityPercentage ){
			e.head.outs.push({
				v: e.tail,
				id: -1
			});
			e.tail.ins.push({
				v: e.head,
				id: -1
			});
		}
		else {
			for( var j=0; j<e.ids.length; j++ ){
				e.head.outs.push({
					v: e.tail,
					id: e.ids[j]
				});
				e.tail.ins.push({
					v: e.head,
					id: e.ids[j]
				});
			}
		}
	}
	for( var i=0; i<this.vertices.length; i++ ){
		var v = this.vertices[i];
		var yv = (v.y1+v.y2)/2;
		if( this.vertices[i].token == "" && ( this.vertices[i].ins.length <= 1 || this.vertices[i].outs.length <= 1 ) ){
			this.vertices[i].ins = [{}];
			this.vertices[i].outs = [{}];
		}
		this.vertices[i].ins.sort(function(t1,t2){			
			var y1 = (t1.v.y1+t1.v.y2)/2;
			var y2 = (t2.v.y1+t2.v.y2)/2;
			if( t1.v == t2.v && t1.id > t2.id ){
				return 1;
			}
			else if( t1.v != t2.v && y1 == y2 && t1.v.x2 > t2.v.x2 ){
				return 1;
			}
			else if( t1.v != t2.v && y1 > y2 ){
				return 1;
			}
			return -1;
		});
		this.vertices[i].outs.sort(function(t1,t2){
			var y1 = (t1.v.y1+t1.v.y2)/2;
			var y2 = (t2.v.y1+t2.v.y2)/2;
			if( t1.v == t2.v && t1.id > t2.id ){
				return 1;
			}
			else if( t1.v != t2.v && y1 == y2 && t1.v.x2 < t2.v.x2 ){
				return 1;
			}
			else if( t1.v != t2.v && y1 > y2 ){
				return 1;
			}
			return -1;
		});
	}
	var getShift = function(id,array){
		if( array.length == 1 ){
			return 0;
		}
		for( var i=0; i<array.length; i++ ){
			if( array[i].id == id ){
				return i*3 - array.length*3/2;
			}
		}
	}
	var getShiftHeight = function(id,array,height){
		if( array.length == 1 ){
			return 0;
		}
		for( var i=0; i<array.length; i++ ){
			if( array[i].id == id ){
				return (i*3 - array.length*3/2)/(array.length*2)*height/2;
			}
		}
	}
	for( var i=0; i<edges.length; i++ ){
		var e = edges[i];
		var c = this.getConnection(e.head,e.tail);
		if( !c ){
			continue;
		}
		if( majority && e.weight > this.sentencePaths.length*this.config.options.majorityPercentage ){
			var path = null;
			if( this.config.options.interpolateFontSize ){
				path = this.generatePath(c,getShiftHeight(-1,e.head.outs,e.head.boxHeight),getShiftHeight(-1,e.tail.ins,e.tail.boxHeight));
			}
			else {
				path = this.generatePath(c,getShift(-1,e.head.outs),getShift(-1,e.tail.ins));
			}
			var pvis = this.paper.path(path).attr({stroke: this.config.options.baseColor, "stroke-width": 5, "stroke-linecap": "round", "opacity": "0.8"});
			pvis.node.setAttribute("class","majority-edgestyle");
			this.addEdgeToGroup(e.head,e.tail,pvis,e.ids);
			this.basicConnections.push(pvis);
		}
		else {
			for( var j=0; j<e.ids.length; j++ ){
				var path = null;
				if( this.config.options.interpolateFontSize ){
					path = this.generatePath(c,getShiftHeight(e.ids[j],e.head.outs,e.head.boxHeight),getShiftHeight(e.ids[j],e.tail.ins,e.tail.boxHeight));
				}
				else {
					path = this.generatePath(c,getShift(e.ids[j],e.head.outs),getShift(e.ids[j],e.tail.ins));
				}
				var pvis = this.paper.path(path).attr({stroke: this.colorMap[this.editions[e.ids[j]]], "stroke-width": 3, "stroke-linecap": "round", "opacity": "0.8"});
				pvis.node.setAttribute("class","edition"+e.ids[j]+"-edgestyle");
				this.addEdgeToGroup(e.head,e.tail,pvis,[e.ids[j]]);
				this.basicConnections.push(pvis);
			}
		}
	}
	for( var i=0; i<this.vertices.length; i++ ){
		var v = this.vertices[i];
		if( v == this.startVertex || v == this.endVertex || v.token == '' ){
			continue;
		}
		if( this.config.options.vertexBackground ){
			v.rect.toFront();
		}
		if( v.count > this.config.options.collapseLabels ){
			v.textNode.toFront();
		}
	}
};

/**
 * Aligns all vertices horizontally, so that all overlaps are removed and a minimum gap between adjacent is given.
 */
TRAViz.prototype.setXFlow = function(){
	var gap = 4*this.curveRadius;
	var edges = [];
	for( var i=0; i<this.startVertex.successors.length; i++ ){
		edges.push({
			head: this.startVertex,
			tail: this.graph.getVertex(this.startVertex.successors[i])
		});
	}
	var widthS = this.startVertex.boxWidth;
	this.startVertex.x1 = gap;
	this.startVertex.x2 = gap + widthS;
	while( edges.length > 0 ){
		var new_edges = [];
		for( var i=0; i<edges.length; i++ ){
			var e = edges[i];
			var g = gap;
			if( e.tail.x1 < e.head.x2 + g ){
				e.tail.x1 = e.head.x2 + g;
				e.tail.x2 = e.head.x2 + g + e.tail.boxWidth;
				for( var j=0; j<e.tail.successors.length; j++ ){
					new_edges.push({
						head: e.tail,
						tail: this.graph.getVertex(e.tail.successors[j])
					});
				}
			}
		}
		edges = new_edges;
	}
	var largestMove = 3;
	while( largestMove > 2 ){
		largestMove = 0;
		for( var i=0; i<this.vertices.length; i++ ){
			var v = this.vertices[i];
			if( v == this.startVertex || v == this.endVertex ){
				continue;
			}
			var x_old = Math.floor(( v.x2 + v.x1 ) / 2);
			var w = v.boxWidth;
			var x_left = undefined, x_right = undefined;
			for( var j=0; j<v.predecessors.length; j++ ){
				var vp = this.graph.getVertex(v.predecessors[j]);
				var xp = vp.x2;
				if( vp == this.startVertex && !this.config.options.startAndEnd ){
					x_left = Math.floor(v.x1 - gap);
				}
				if( typeof x_left == "undefined" || xp > x_left ){
					x_left = xp;
				}
			}
			for( var j=0; j<v.successors.length; j++ ){
				var vs = this.graph.getVertex(v.successors[j]);
				var xs = vs.x1;
				if( vs == this.endVertex && !this.config.options.startAndEnd ){
					x_right = Math.floor(v.x2 + gap);
				}
				if( typeof x_right == "undefined" || xs < x_right ){
					x_right = xs;
					xr = vs;
				}
			}
			var x_new = Math.floor(( x_left + x_right ) / 2);
			if( isNaN(x_new) ){
				x_new = x_old;
			}
			if( x_new != x_old ){
				v.x1 = x_new - w/2;
				v.x2 = v.x1 + w;
				if( largestMove < Math.abs(x_new-x_old) ){
					largestMove = Math.abs(x_new-x_old);
				}
			}
		}
	}
};

/**
 * Test if the given bounds overlap each other.
 */
TRAViz.prototype.overlap = function(x1_min,x1_max,x2_min,x2_max,y1_min,y1_max,y2_min,y2_max){
	if( x1_min >= x2_max || x1_max <= x2_min || y1_min >= y2_max || y1_max <= y2_min ){
		return false;
	}
	return true;
}

/**
 * Getter for the layer with the given <index>
 */
TRAViz.prototype.getLayer = function(index){
	for( var i=0; i<this.layers.length; i++ ){
		if( this.layers[i].index == index ){
			return this.layers[i];
		}
	}
	return false;
}

/**
 * Getter for the array_index for the layer with the given <index>
 */
TRAViz.prototype.getLayerIndex = function(index){
	for( var i=0; i<this.layers.length; i++ ){
		if( this.layers[i].index == index ){
			return i;
		}
	}
	return false;
}

/**
 * Computes all connections dependent on the current vertex positions.
 */
TRAViz.prototype.setConnections = function(){
	this.prepareConnections();
	var y = 1000;
	for( var i=0; i<this.layers.length; i++ ){
		this.horizontalSlots[i].yMin = y+this.curveRadius;
		this.horizontalSlots[i].yMax = y-this.curveRadius+this.horizontalSlots[i].height;
		y += this.layers[i].height/2 + this.horizontalSlots[i].height;
		this.layers[i].yLevel = 0+y;
		for( var j=0; j<this.layers[i].vertices.length; j++ ){
			var heightN = this.layers[i].vertices[j].boxHeight;
			this.layers[i].vertices[j].y1 = y - heightN / 2;
			this.layers[i].vertices[j].y2 = y + heightN / 2;
		}
		y += this.layers[i].height/2;
	}
	this.adjustHorizontalConnections();
	this.adjustVerticalConnections();
}

/**
 * Draw the edition with <id> on the main branch (all vertices of edition <id> will appear on the same horizontal level).
 */
TRAViz.prototype.setMainBranch = function(id){
	if( this.mainBranch != id ){
		this.mainBranch = id;
		this.reset();
		this.visualize();
	}
};

/**
 * Computes the path of the given transposition between <v1> and <v2>
 */
TRAViz.prototype.generateTranspositionPath = function(v1,v2){
	var bezier = function(x1,y1,xb,yb,x2,y2){
		return "C "+x1+" "+y1+" "+xb+" "+yb+" "+x2+" "+y2+" ";
	}
	var line = function(x1,y1,x2,y2){
		return "L "+x1+" "+y1+" "+x2+" "+y2+" ";
	}
	var x1 = v1.x, x2 = v2.x;
	var y1, y2, y3, y4, y5;
	var l1 = this.getLayer(v1.layer);
	var l2 = this.getLayer(v2.layer);
	var cr = Math.min(this.curveRadius,Math.abs(x1-x2)/2);
	if( l1 == l2 ){
		var y1 = v1.y2;
		var y2 = (v1.y1+v1.y2)/2 + l1.height/2;
		var y3 = (v1.y1+v1.y2)/2 + l1.height/2 + cr;		
		var y4 = (v2.y1+v2.y2)/2 + l1.height/2;
		var y5 = v2.y2;
	}
	else if( l1.index < l2.index ){
		var hsh = this.horizontalSlots[this.getLayerIndex(v1.layer)+1].yMax - this.horizontalSlots[this.getLayerIndex(v1.layer)+1].yMin;
		var y1 = v1.y2;
		var y2 = (v1.y1+v1.y2)/2 + l1.height/2 + hsh/2;
		var y3 = (v1.y1+v1.y2)/2 + l1.height/2 + hsh/2 + cr;		
		var y4 = y3 + cr;
		var y5 = v2.y1;
	}
	else if( l1.index > l2.index ){
		var hsh = this.horizontalSlots[this.getLayerIndex(v1.layer)].yMax - this.horizontalSlots[this.getLayerIndex(v1.layer)].yMin;
		var y1 = v1.y1;
		var y2 = (v1.y1+v1.y2)/2 - l1.height/2 - hsh/2;
		var y3 = (v1.y1+v1.y2)/2 - l1.height/2 - hsh/2 - cr;		
		var y4 = y3 - cr;
		var y5 = v2.y2;
	}
	var path = "M "+x1+" "+y1+" ";
	path += line(x1,y1,x1,y2);
	path += bezier(x1,y2,x1,y3,x1+cr,y3);
	path += line(x1+cr,y3,x2-cr,y3);
	path += bezier(x2-cr,y3,x2,y3,x2,y4);
	path += line(x2,y4,x2,y5);
	return path;	
}

/**
 * Calculates minimum spanning trees for (potential) transpositions.
 */
TRAViz.prototype.calculateTranspositions = function(){
	var groups = [];
	for( var i=0; i<this.vertices.length; i++ ){
		if( this.vertices[i] == this.startVertex || this.vertices[i] == this.endVertex || this.vertices[i].token == '' ){
			continue;
		}
		this.vertices[i].x = (this.vertices[i].x1+this.vertices[i].x2)/2;
		var found = false;
		for( var j=0; j<groups.length; j++ ){
			if( groups[j][0].token == this.vertices[i].token ){
				groups[j].push(this.vertices[i]);
				found = true;
				break;
			}
		}
/*
		if( this.config.options.editDistance ){
			for( var j=0; j<groups.length; j++ ){
				var g = groups[j];
				for( var k=0; k<g.length; k++ ){
					for( var l=0; l<g[k].sources.length; l++ ){
						for( var m=0; m<this.vertices[i].sources.length; m++ ){
							var ld = this.aligner.getEditDistance(g[k].sources[l].token,this.vertices[i].sources[m].token);
							var red = 2*ld / (g[k].sources[l].token.length+this.vertices[i].sources[m].token.length);
							if( red <= this.config.options.editDistance ){
								groups[j].push(this.vertices[i]);
								found = true;
								break;
							}
						}
					}
				}
			}
		}
*/
		if( !found ){
			groups.push([this.vertices[i]]);
		}
	}
	for( var i=0; i<groups.length; i++ ){
		var g = groups[i];
		if( g.length == 1 ){
			continue;
		}
		for( var j=0; j<g.length; j++ ){
			g[j].transpositions = [];
			g[j].transpositionGroup = g;
			for( var k=0; k<g.length; k++ ){
				if( j == k ){
					continue;
				}
				var path = "";
				if( g[j].x < g[k].x ){
					path = this.generateTranspositionPath(g[j],g[k]);
				}
				else {
					path = this.generateTranspositionPath(g[k],g[j]);
				}
				var p = this.paper.path(path).attr({"stroke-width": 3, "stroke-dasharray":'.', "opacity": "1.0"});
				g[j].transpositions.push(p);
			}
		}
	}
	/*
	var distance = function(v1,v2){
		var x1 = (v1.x1 + v1.x2)/2;
		var y1 = (v1.y1 + v1.y2)/2;
		var x2 = (v2.x1 + v2.x2)/2;
		var y2 = (v2.y1 + v2.y2)/2;
		v1.x = x1;
		v1.y = y1;
		v2.x = x2;
		v2.y = y2;
		return Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));
	}
	for( var i=0; i<groups.length; i++ ){
		var g = groups[i];
		if( g.length == 1 ){
			continue;
		}
		var matrix = new AdjMatrix(g.length);
		for (var k = 0; k < g.length - 1; k++) {
			for (var l = k + 1; l < g.length; l++) {
				matrix.setEdge( k, l, distance(g[k],g[l]) );
			}
		}
		var tree = Prim(matrix);
		var paths = [];
		for (var z = 0; z < tree.length; z++) {
			var v1 = g[tree[z].v1];
			var v2 = g[tree[z].v2];			
			var path = "";
			if( v1.x < v2.x ){
				path = this.generateTranspositionPath(v1,v2);
			}
			else {
				path = this.generateTranspositionPath(v2,v1);
			}
			var p = this.paper.path(path).attr({"stroke-width": 4, "stroke-dasharray":'.', "opacity": "1.0"});
			$(p.node).css('display','none');
			paths.push(p);
		}
		for( var j=0; j<g.length; j++ ){
			g[j].transpositions = paths;
		}
	}
	*/
};

/*

Copyright (C) 2014, Stefan Jänicke.

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the "Software"),
to deal in the Software without restriction, including without limitation
the rights to use, copy, modify, merge, publish, distribute, sublicense,
and/or sell copies of the Software, and to permit persons to whom the
Software is furnished to do so, subject to the following conditions:

1. The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

2. It is prohibited to remove, hide or modify any visual copyright notice
generated by this Software.

3. When using screenshots of any part of the visual output generated by
this Software for presentations or on websites the following link MUST
be clearly visible for the beholder: http://traviz.vizcovery.org

4. When using screenshots of any part of the visual output generated by
this Software in publications, the following reference MUST be inserted: 

S. Jänicke, A. Geßner, M. Büchler and G. Scheuermann (2014). Visualizations
for Text Re-use. In Proceedings of the 5th International Conference on
Information Visualization Theory and Applications, IVAPP 2014, pages 59–70.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

(Fair Academic License (FAL), http://vizcovery.org/fal.html)

*/


/**
 * Getter for a unique vertex index (required for vertex hash in the graph)
 */
TRAVizConfig.prototype.getVertexIndex = function(){
	if( typeof this.vid == 'undefined' ){	
		this.vid = 0;
	}
	return ++this.vid;
};

/**
 * converts HSV to RGB
 * adapted from http://jsres.blogspot.de/2008/01/convert-hsv-to-rgb-equivalent.html
 */
TRAVizConfig.prototype.Hsv2rgb = function(h,s,v){
	var r, g, b;
	var var_h = h * 6;
	if(var_h==6){
		var_h = 0;
	}
	var var_i = Math.floor( var_h );
	var var_1 = v*(1-s);
	var var_2 = v*(1-s*(var_h-var_i));
	var var_3 = v*(1-s*(1-(var_h-var_i)));
	if(var_i==0) { 
		var_r = v; 
		var_g = var_3; 
		var_b = var_1;
	}
	else if(var_i==1) {
		var_r = var_2;
		var_g = v;
		var_b = var_1;
	}
	else if(var_i==2) {
		var_r = var_1;
		var_g = v;
		var_b = var_3
	}
	else if(var_i==3){
		var_r = var_1;
		var_g = var_2;
		var_b = v;
	}
	else if(var_i==4){
		var_r = var_3;
		var_g = var_1;
		var_b = v;
	}
	else{
		var_r = v;
		var_g = var_1;
		var_b = var_2
	}
	return "rgb("+Math.round(var_r*255)+","+Math.round(var_g*255)+","+Math.round(var_b*255)+")";
};

/**
 * Getter for an arbitrary number of colors
 * if <num> is larger than the configuration color array, randomly generated saturated colors are added
 */
TRAVizConfig.prototype.getColors = function(num){
	var colors = [];
	for( var i=0; i<num; i++ ){
		if( i >= this.options.colors.length ){
			colors.push(this.Hsv2rgb(((Math.random()*360)+1)/360,1,(25 + (Math.random()*50)+1)/100));
		}
		else {
			colors.push(this.options.colors[i]);
		}
	}
	return colors;
};
function TRAVizConfig(options) {

	this.options = {

		/* General */
		colors: [ "red", "blue", "green", "rgb(230,230,0)", "orange",
                      "#996600", "purple", "#FF00FF", "#66FFFF", "#339999" ], // colors used to identify the various edition flows		
		normalize: true, // if the sentences shall be normalized or not (remove special characters)
		lineBreaks: true, // if line breaks are allowed or not (if true, only the width of the given div is used)
		lineNumbering: true, // if line numbers are shown when lineBreaks are used
		lineNumberingText: "Line ", // text of line numbers
		rtl: false, // if labels should be drawn from right to left (for arabic, hebrew)
		popupLabel: "occurrences", // header label to be shown in the popup window
		optimizedAlignment: true, // computes a better alignment at the expense of runtime
		editionLabels: true, // if edition labels are shown in a popup when hovering edges

		/* Text Vertices */		
		baseColor: '#3E576F', // color used for text and joined connections		
		vertexBackground: 'rgba(242,242,242,0.75)', // false or a CSS color for the text backgrounds		
		font: 'Georgia', // text font		
		startAndEnd: true, // if start and end vertex are shown and linked to all paths
		collapseLabels: 0, // text labels are only shown for vertices with more than the given value
		interpolateFontSize: false, // if true, the font size of the vertices is interpolated between 'fontSizeMin' and 'fontSizeMax'
		fontSizeMin: 10, // minimum font size
		fontSizeMax: 50, // maximum font size
		fontSizeIncrease: 4, // the number of pixels the labels grow by edition if interpolateFontSize = false
		
		/* Connections */
		edgeGap: 5, // minimum gap between two connections; required when adjusting the connections horizontally and vertically		
		curveRadius: 10, // radius of the curves
		connectionType: 'all', // how the connections shall be displayed: 
						// 'all' for displaying each individual stream, 
						// 'joined' to merge all parallel connections, or 
						// 'majority' to merge only if more than half of the edges are routed between the same vertices
		majorityPercentage: 0.5, // an edge becomes a majority edge when the given percentage of editions passes it

		editDistance: false, // false (or 0) if only exact matches between two words shall be merged or edit distance dependent on the word lengths computed with the formula 2*editDistance/(|word1|+|word2|)

		splitAndMerge: true, // if the user is allowed to interactively split vertices or merge via drag&drop

		transpositions: true, // if transpositions shall be determined and visualized on mouseover

	};
    for (const [key, value] of Object.entries(options)){
        this.options[key] = value;
    }
};
